%---------------------------------------------------------------------------
% Chapter 1 - Introduction
%
%---------------------------------------------------------------------------
\chapter{Introduction}
\label{cha:intro}


\parbox{0.8\textwidth}{
\makebox{\large Abstract}

{\small
Monitoring of software systems that are more and more complex is a challenging task. At the beginning of this chapter, I would like to introduce the measuring systems problem domain and my personal motivation into the subject. In the next part, user may find a definition of objectives that should be achieved with this work. The last section is purely pragmatic - covers description of document structure to make navigation over the thesis a bit easier.
}
}

%---------------------------------------------------------------------------
\section{Motivation}
\label{ch1:Motivation}

Implementation of performance monitoring system is a challenging task. It is a truism to say, but it is just true. It is hard to find the optimal solution, as the problem is multidimensional in nature. Such a system, must leave almost untraceable footprint on application, as bigger overhead on resources usage will spoil actual measurement, making it useless. On the other hand, the user needs loads of information about application to tell whether it works properly or not. How to fetch those data but do not destroy them in the same time? How to grab all those data and do not disturb normal development cycle? How to allow the user to get deep insight into the application, without flooding with views, configuration dialogs, actions or other operations. Implementation of performance monitoring system is undoubtedly a challenging task.

Developer nowadays must be able to working with a vast variety of environments. Applications can operate on mobile and lightweight platforms, standalone desktop computers, clusters of interconnected computers that create homogeneous computational system, up to most complex deployments that use heterogeneous configuration composed of clusters mentioned previously. Although it is rather hard to imagine an application that evolves from one that targets mobile devices, to one that must operate on cluster, or even grid, but a server application that originally was designed to work as a standalone application will need such an evolution process more likely. Such a use case forces the developer to stand against scalability issues.

Development of standalone application is not a straightforward task, so when need to increase processing power emerges and forces it to operate in distributed manner, the complexity increases even more. Distributed environment adds another dimension to application performance optimizations - communication cost between computing nodes.

After deploying application on a grid environment the complexity of a measuring system increases enormously. Such a highly distributed platform, adds other dimensions of problem - issues with source in the heterogeneous nature of grids, reduced reliability, need potentially to share resources with other applications, and finally potential problems with jobs scheduling.

Often it is also required to increase complexity even more, by dividing an application into components created using different technologies, even different programming language. For example, it is not rational to implement HTML-based application front end using C++ or CPU-intensive entropy coding in JavaScript. Such an approach increases performance, scalability, manageability but also complexity, as developers need to know many technologies. Additionally heterogeneous introduces another optimization factor - need to implement efficient interaction between components that are different in nature.

In order to create efficient software, sooner or later developer needs to take performance into account. In order to evaluate application behavior, measurement applications should be employed. Performance evaluation is even more valuable when working with distributed systems, as complexity in this case is significantly greater. Measuring tools, when used in monitoring such a large scale applications, should aid developer in finding potential issues. This includes processing bottlenecks, resources consumption imbalance, finding most optimal communication to computation rate, etc.

Complexity of performance measuring applications increases with increasing scale and complexity of source application. This implies that creation of monitoring application, which can operate in heterogeneous grid environments and that is implemented in more than one programming language is challenging. This process is not trivial in almost every area, like defining use cases, designing data model that logically represents a variety of types, up to the implementation. The last factor especially matters when paying attention to the proper user experience engineering.

Although there are numerous works on the subject, it is still difficult to find the one that will match all those requirements, in a satisfactory manner. Either those applications focus on a single technology or tend to be too complex from a user point of view.

%---------------------------------------------------------------------------

\section{Objectives}
\label{ch1:Objectives}

Main objective of this thesis is to design, implement and document system that can be used easily to monitor a wide range of application types that represent any scale. This includes systems running on a single process, those working on medium scaled clusters, up to highly distributed solutions that use multiple computing nodes within heterogeneous grid environment. Implemented solution should be easy to use by a variety of users - students, lecturers, software engineers or scientists. This last objective was the source of project's code name - SemSimMon, Semantic Simple Monitor.

In order to extend application's life time, it should be released as open source project, and should meet all criteria for such a software: open standards, open protocols, open source dependencies. Additionally, development process should come in pair with extensive documentation, to shorten the learning curve for new or additional developers.

Another aspect of having widely used application is portability. The user should be able to run it on majority of currently available platforms, including all flavors of *nixs (UNIX, Linux, Mac OS X\textregistered) and Microsoft\textregistered~Windows\textregistered. 

\section{Document structure}
\label{ch1:docStructure}

Reader of this Thesis can find its content divided into \ref{cha:summary} chapters.

Chapter~\ref{cha:background} contains a detailed description of the problem domain. It covers background technologies and review of the software with similar purpose. One may find there results of the initial analysis that makes the rest of this work possible.

Chapters ~\ref{cha:requirements}~to~\ref{cha:deployment} focuses solely on the development process of creating an application and covers all steps of an initial development cycle. First there is a description of gathering requirements and formalization into use cases (chapter~\ref{cha:requirements}). As a next step, in Chapter~\ref{cha:sys_arch} I would like to take the reader through the design stage. This chapter covers system analysis, top to bottom. It starts from the highest point of view (high level functional decomposition) and goes down to deep insight into the way each high-level component should work. Chapter~\ref{cha:implementation}) describes Implementation process, where we can find a detailed description of development tools used and a short overview on system from a programming point of view. Description of initial life cycle steps ends on Chapter~\ref{cha:deployment}, which covers tests and deployment of a complete solution.

Additionally, in last Chapter~\ref{cha:summary}, author tries to summarize achieved results. Within this part of thesis, reader may find also short description of ideas on next steps that could be taken to let application evolve.
