%---------------------------------------------------------------------------
% Chapter 1 - Introduction
%
%---------------------------------------------------------------------------
\chapter{Introduction}
\label{cha:intro}


\chabstract{
Monitoring of software systems that are more and more complex is a challenging task. At the beginning of this chapter, I would like to introduce the problem domain of measuring systems and my personal motivation into the subject. In the next part, the user may find a definition of objectives that should be achieved within this work. The last section is purely pragmatic, it covers a description of document structure to make navigation over Thesis a bit easier.
}

%---------------------------------------------------------------------------
\section{Motivation}
\label{ch1:Motivation}

Implementation of performance monitoring system is a challenging task. It is a truism to say, but it is just true. It is hard to find the optimal solution, as the problem is multidimensional in nature. Such a system, must leave almost untraceable footprint on application, as bigger overhead on resources usage will spoil actual measurement, making it useless. On the other hand, the user needs loads of information about application to tell whether it works properly or not. How to fetch those data but do not destroy them in the same time? How to grab all those data and do not disturb normal development cycle? How to allow the user to get deep insight into the application, without flooding with views, configuration dialogs, actions or other operations. Implementation of performance monitoring system is undoubtedly a challenging task.

Developer nowadays must be able to working with a vast variety of environments. Applications can operate on mobile and lightweight platforms, standalone desktop computers, clusters of interconnected computers that create homogeneous computational system, up to the most complex deployments that use heterogeneous configurations of computers. Although it is rather hard to imagine an application that evolves from one targeting mobile devices to another one that must operate on cluster, or even grid, but a server application that originally was designed to work as a standalone application will need quite probably such an evolution process. Such a use case forces the developer to tackle scalability issues.

The development of standalone applications is not a straightforward task, so when a need to increase processing power emerges and forces it to operate in distributed manner, the complexity increases even more. Distributed environment adds another dimension to application performance optimizations - communication cost between computing nodes.

After deploying an application in a grid environment, the complexity of a measuring system increases enormously. Such a highly distributed platform adds other dimensions to the problem, e.g. issues with source in the heterogeneous nature of grids, reduced reliability, need potentially to share resources with other applications, and at last but not least problems with job scheduling.

Often it is also required to increase the complexity even more, by dividing an application into components created with different technologies, even different programming languages. For example, it is not reasonable to implement HTML-based application front end using C++ or CPU-intensive entropy coding in JavaScript. Such an approach increases performance, scalability, manageability but also complexity, as developers need to know many technologies. Additionally, heterogeneity introduces another optimization factor - a need to implement efficient interaction between components that are different by nature.

In order to create efficient software, sooner or later the developer needs to take performance into account. In order to evaluate application\rq{}s behavior, measurement facilities should be employed. Performance evaluation is even more valuable when working with distributed systems, as complexity in this case is significantly greater. Measurement tools, when used in monitoring such a large scale applications, should aid the developer in finding potential issues. This includes execution bottlenecks, resources consumption imbalance, finding the most optimal communication to computation rate, etc.

The complexity of performance measuring applications increases with the increasing scale and complexity of source application. This implies that the creation of monitoring application, which can operate on heterogeneous grid environments and that is implemented in more than one programming language is challenging. This process is not trivial in almost every area, like defining use cases, designing data model that logically represents a variety of types, up to the implementation. The last factor especially matters when paying attention to the proper user experience engineering.

Although there are numerous work on the subject, it is still difficult to find the one that will match all those requirements, in a satisfactory manner. Either those applications focus on a single technology or tend to be too complex from the user\rq{}s point of view.

%---------------------------------------------------------------------------

\section{Objectives}
\label{ch1:Objectives}

The main objective of this thesis is to design, implement and document a system that can be used easily to monitor a wide range of application types that represent any scale. This includes systems running on a single-process, those working on medium scaled clusters, up to highly distributed solutions that use multiple computing nodes within heterogeneous grid environment. The solution to be implemented should be easy-to-use for a variety of users - students, lecturers, software engineers, or scientists. This last objective influenced project's code name - SemSimMon, Semantic Simple Monitor.

In order to extend application's life time, it should be released as open source project, and should meet all the criteria for such a software: open standards, open protocols, open source dependencies. Additionally, the development process should come in pair with extensive documentation, to shorten the learning curve for new developers.

Another aspect of having a widely used application is portability. The user should be able to run it on a majority of currently available platforms, including all flavors of *nixs (UNIX, Linux, Mac OS X\textregistered) and Microsoft\textregistered~Windows\textregistered. 

\section{Document structure}
\label{ch1:docStructure}

The reader of this Thesis can find its content divided into \ref{cha:summary} chapters.

Chapter~\ref{cha:background} contains a detailed description of the problem domain. It covers background technologies and a review of the software with a similar purpose. One may find there results of an initial analysis that makes the rest of this work possible.

Chapters ~\ref{cha:requirements}~to~\ref{cha:deployment} focus solely on the development process of creating a system and covers all steps of an initial development cycle. First there is a description of gathering user requirements and formalization into use cases (Chapter~\ref{cha:requirements}). As a next step, in Chapter~\ref{cha:sys_arch} I would like to take the reader through a design stage. This chapter covers system analysis, top to bottom. It starts from the highest point of view (a high-level functional decomposition) and goes down to a deep insight into the way each high-level component should work. Chapter~\ref{cha:implementation}) describes the implementation process, where we can find a detailed description of development tools used and a short overview on the system from a programming point of view. The description of initial life cycle steps ends in Chapter~\ref{cha:deployment}, which covers tests and deployment of the complete solution.

Additionally, in last Chapter~\ref{cha:summary}, the author tries to summarize the results achieved. Within this part of thesis, the reader may find also a short description of ideas on next steps that could be taken to let the application evolve.
