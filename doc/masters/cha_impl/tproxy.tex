\section{Transport Proxy Implementation}

\subsection{JMX Transport Proxy Implementation}

JMX Transport Proxy is build around two concepts: discovery agent and capability probe. Implementation consist following discovery agent classes:

\begin{itemize} 
  \item{\bf{GCDiscoveryAgent}} - discovers garbage collectors 
  \item{\bf{ThreadsDiscoveryAgent}} - discovers all threads running in single JVM
  \item{\bf{CPUDiscoveryAgent}} - discovers CPUs on given computing node
  \item{\bf{JvmDiscoveryAgent}} - discovers JVM running on a node
  \item{\bf{OsDiscoveryAgent}} - discovers an operating system that runs on given node
\end{itemize} 

Additionally the JMX Transport proxy uses following probes to fetch capability values: 

\begin{itemize} 
  \item{\bf{GarbageCollectionsProbe}} - gets values of a Garbage Collector related capabilities (CollectionCountCapability and CollectionTimeCapability)
  \item{\bf{MemoryProbe}} - gathers values of a memory related capabilities: total, free and used. It is used in conjunction with both a physical and a virtual memory resources
  \item{\bf{HeapProbe}} - measures heap usage  
  \item{\bf{ThreadTimingProbe}} - monitors threads timings: ThreadCPUTimeCapability and ThreadUserTimeCapability capabilities
  \item{\bf{ThreadSynchronizationDetailsProbe}} - monitors capabilities related to a thread\rq{}s synchronization: ThreadBlockedCountCapability, ThreadBlockedTimeCapability, ThreadWaitedCountCapability and ThreadWaitedTimeCapability
  \item{\bf{JmxQueryCapabilityProbe}} - generic probe that can measure capabilities using JMX query
\end{itemize} 

\subsection{OCM-G Transport Proxy Implementation}

The OCM-G Transport Proxy implementation uses similar approach to the JMX one. In this case, there are also two concepts employed: probes (works in same way as in JMX Transport Proxy) and resource agents. The OCM-G proxy consists of resource agents instead of discovery agents, because the OCM-G have means to actually manage resources and those means are used in the SemSimMon. Thus, resource agents have two purposes - discovery and management of resources.

There are following resource agents implemented:

\begin{itemize} 
  \item{\bf{AppsResourceAgent}} - manages applications monitored by given MainSM
  \item{\bf{ClustersResourceAgent}} - manages clusters within given application
  \item{\bf{NodeResourceAgent}} - manages nodes within given cluster
  \item{\bf{ProcessFunctionsResourceAgent}} - manages function resources
  \item{\bf{ThreadResourceAgent}} - manages threads
  \item{\bf{CpuResourceAgent}} - manages processors
  \item{\bf{NetIfaceResourceAgent}} - manages network interfaces
  \item{\bf{OSResourceAgent}} - manages operating systems
  \item{\bf{PhysicalMemoryRA}} - manages physical memory
  \item{\bf{ProcessResourceAgent}} - manages processes
  \item{\bf{StorageResourceAgent}} - manages storage devices
  \item{\bf{VirtualMemoryRA}} - manages virtual memory
 \end{itemize} 
  
The OCM-G Transport Proxy uses following probes:

\begin{itemize} 
  \item{\bf{LoadAvgProbe}} - measures the node\rq{}s load average 
  \item{\bf{ThreadsCP}} - measures capabilities related to threads (total and live threads count)
  \item{\bf{TotalCpuTimeCapabilityProbe}} - measures total CPU time of a process
  \item{\bf{FunctionProbe}} - measures capabilities related to functions (TotalCallsTimeCapability and TotalCallsCountCapability)
\end{itemize} 

\subsection{TransportProxy interface}
\label{subs:TransportProxyInterface}

Although Transport Proxies are components where most of \lq\lq{}the magic\rq\rq{} occurs, its implementation is relatively simple. To use functionalities provided by this component, the Monitoring Hub uses only one single interface, which can be seen in Figure~\ref{fig:transport_proxy}.

\begin{figure}[ht]
  \centering
  \input{cha_impl/TransportProxy_java}
  \caption{Listing of TransportProxy.java}
  \label{fig:transport_proxy}
\end{figure} 

Additionally, to make extending of the application with a new transport proxy even more simple, the BaseTransportProxy class was introduced. Its main purpose is to implement most of functionalities that are not aware of underlaying communication mechanisms. Because of that, one should just create a new class that inherits from the BaseTransportProxy and implement only abstract methods that are defined there to add new transport proxy.
