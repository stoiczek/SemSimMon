%---------------------------------------------------------------------------
% Knowledge component.
%
%---------------------------------------------------------------------------
\section{Knowledge component}
\label{sec:arch_knowledge}

Knowledge component is responsible for realization of semantic approach to the proposed system. Although end-user can barely notice its existence, it is crucial to allow high scalability and ease of use. Ontologies provided by system give generic measurement semantic. Such an approach allows the user to get to know system only once and work using it with many different types of hardware, protocols. He or She can work with any measurable item types that can be mapped into generic components introduced by ontologies. Additionally it allows to work with all those different items simultaneously; thus, it makes it possible to monitor an application that is written using different, cooperating technologies.

\subsection{Default ontologies}

All system functionalities are built around two main ontologies - first one grouping resources, and the second, covering resource capabilities. Main principle, I have been trying to follow, while designing them was to maximize wideness of applications that can be monitored using SemSimMon system - from those running single process on one computing machine, up to highly distributed, grid-based ones.

Two root concepts must be explained: concept of a resource and a capability in order to describe proposed ontologies in more detail. Every other entity used in the application is a subclass of one of them. The resource class wraps all components that are being used to perform requested computations. Resource can be a physical device that takes part in computation (hardware resources), or any software component that can be either dependency (library) or one that the user creates (program, library). The capability concept generalizes all measurable features of each resource. Capabilities exist only in the context of resources that contain them. Resource may have multiple capabilities and given capability may exist within the context of multiple resources.

Both those ontologies are described using diagrams containing two types of relationships: is-a, and has-a. Is-a relationship, is formalized as rdfs:subClassOf and states that all instances of one class are instances of another\cite{rdfRef:2004}. Has-a relationship describes resources only. Main purpose of this relationship is to show composition arrangement. It aims in easing understanding of which resources given parent resource use (e.g. virtual machine uses class loader, garbage collector; one or more CPU builds computing node, storage device, network device and so on).

In following diagrams, entities are drawn as filled ellipse with entity name inside. The graphical representation of is-a relationship between two entities is a hollow triangle shape on the super type end of the line that connects it to one or more subtypes. Diagrams use line with an arrowhead indicating an owned side of a relationship to represent has-a relation. UML use case diagram specification was the source of inspiration for this notation.

\pagebreak

\subsection{Resources ontology}
\label{subsec:arch_knowledge_resources}

Resources ontology complexity, forced me to split diagrams containing both is-a and has-a relationships into 3 parts: the one containing most general classes (application, node, and cluster), second one for hardware resources and software resources diagram. 

\begin{figure}[ht]
\centering
\includegraphics[width=0.6\textwidth]{onto_resources_admin}
\caption{Diagram of is-a (rdfs:subClassOf) relationship between most general resource concepts}
\label{fig:onto_resources_admin}
\end{figure}

Figure~\ref{fig:onto_resources_admin} depicts is-a relationship between general SemSimMon concepts. The root class of every entity in OWL compliant ontologies is owl:Thing, as specified in OWL language reference\cite{owlRef:2004}. I have introduced generic Resource class to cover all possible resources. It acts as a root concept for all other resources and the only one that is a direct subclass of owl:Thing. Resource has 6 direct subtypes: Application, Cluster, Node, Memory, HardwareResource and SoftwareResource. Application and Cluster types are so called \lq\lq{}management\rq\rq{} class resources - they do not represent actual components, which can be used to perform computations. Instead, they can be used to aggregate one or more elements, which allows the user to building more manageable measurement structures. Application is the most notable item, in the context of has-a relationship, which illustrates Figure~\ref{fig:onto_resources_has_a_admin}. It represents program created by the user, which He or She wants to analyze using proposed tool. Each application, in a theoretical model may be running on multiple clusters, and multiple nodes.

Cluster refers to group of computing nodes, which are connected using high-efficiency network, thus in some way may be treated as a single entity. It is equivalent of site in OMIS nomenclature\cite{tl9702e}. Node can be interpreted as a bridge between high-level resources and software, hardware resources. It is smallest independent computing unit, e.g. single PC or unit in a rack. It can be treated as an administrative resource type, as it is not a component that is used directly, but one that those components. On the other hand, node is an actual processing device.

There exists also noteworthy class of resources - Memory. It was extracted to subclass Resource type directly, because there exists at least two types of memory: software based (virtual memory) and hardware (physical memory) that share common semantics.

\begin{figure}[ht]
\centering
\includegraphics[width=0.3\textwidth]{onto_resources_has_a_admin}
\caption{Diagram of has-a relationship between most general resource concepts}
\label{fig:onto_resources_has_a_admin}
\end{figure}

\pagebreak

\begin{figure}[ht]
\centering
\includegraphics[width=0.6\textwidth]{onto_resources_hardware}
\caption{Diagram of is-a relationship between hardware resources}
\label{fig:onto_resources_hardware}
\end{figure}

Classes related to hardware resources, can be seen in Figures~\ref{fig:onto_resources_hardware} and~\ref{fig:onto_resources_has_a_hardware}. The design of all of them allows covering most of computer parts available nowadays on market. Both diagrams are quite straightforward. HardwareResource has 4 direct sub-types: PhysicalMemory, StorageResource, NetworkInterface and CPU. PhysicalMemory, is also subtype of Memory class, to share common semantics. Also, StorageResource has one deriving class - HardDisk. Hardware resources has-a relationship diagram is even more elementary - Node may have all hardware resources, and there are no other relations between those resources.

\begin{figure}[ht]
\centering
\includegraphics[width=0.7\textwidth]{onto_resources_has_a_hardware}
\caption{Diagram of has-a relationship between hardware resources}
\label{fig:onto_resources_has_a_hardware}
\end{figure}

\begin{figure}[ht]
\centering
\includegraphics[width=0.9\textwidth]{onto_resources_software}
\caption{Diagram of is-a relationship between software resources}
\label{fig:onto_resources_software}
\end{figure}

System is aware of more software than hardware resource types. This implies sophisticated relationships between concepts depicted in Figures~\ref{fig:onto_resources_software} and~\ref{fig:onto_resources_has_a_software}. Class SoftwareResource has 4 direct subtypes: VirtualMemory (which also derives from generic Memory concept), OperatingSystem, Process and SoftwareComponent concept. First three types are quite straightforward and represent what one expects them to do. Special subtype of Process, namely VirtualMachine needs more concern. It was extracted from general type, because of its nature, which differs it from all general-purpose processes. Each virtual machine acts as runtime environment for running application; thus, it has features common for all virtual machines, but unlikely seen in casual process. SoftwareComponent resource type is logical wrapper for all low level software components that can be used to create a program. There are generic components, like Thread, Function. There are also types specific to Object Oriented Programming: Class, Object, and Method (which subtypes Function). The third group of SoftwareComponents subtypes is specific to virtual machines. It contains only two items: GarbageCollector and ClassLoader.

Regarding ownership relations in software category there is one root concept - Node. Each node has OperatingSystem, and multiple Processes. Some processes may be a VirtualMachine, which makes this resource is the last type that Node may directly own. Each process may have following software components: Thread, Object, Class and Function. VirtualMachine may have all components that generic process has and two more specific: ClassLoader and GarbageCollector. Additionally, Class type owns single one resource type, the Method. OperatingSystem resource may have only one software resource type, namely VirtualMemory.

\begin{figure}[ht]
\centering
\includegraphics[width=0.7\textwidth]{onto_resources_has_a_software}
\caption{Diagram of has-a relationship between software resources}
\label{fig:onto_resources_has_a_software}
\end{figure}

\pagebreak

\subsection{Capabilities ontology}
\label{subsec:arch_knowledge_capabilitie}

For concepts related to capabilities of resources, only is-a relationship was defined, which can be seen in Figure~\ref{fig:onto_capabilities}. There is one root concept, namely ResourceCapability, which subclasses rdf:Thing. It has 4 direct subtypes: HardwareCapability, MemoryCapability, NodeCapability and SoftwareCapability. For hardware capability, there are only 2 deriving classes StorageCapability and CpuCapability. Since the concepts of VirtualMemory and PhysicalMemory are semantically close, there is no need to subclass generic MemoryCapability; thus, this type does not have any subtypes. NodeCapability is another direct subtype of most generic ResourceCapability, which does not require any additional child types.

Complex structure of software resources influences relationships between capabilities related to those components. SoftwareCapability has 3 subtypes: OperatingSystemCapability, ProcessCapability and SoftwareComponentCapability. Additionally, VirtualMachineCapability was extracted from ProcessCapability, because of same reasons that motivate extraction of VirtualMachine resource type from Process - different semantics. The only one type that extends SoftwareComponentCapability is ThreadCapability.

\begin{figure}[ht]
\centering
\includegraphics[width=1.0\textwidth]{onto_capabilities}
\caption{Diagram of is-a relationship between capabilities}
\label{fig:onto_capabilities}
\end{figure}

